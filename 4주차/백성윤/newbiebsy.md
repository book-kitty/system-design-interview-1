# 유일 ID 생성기 설계

## 1. 문제
> 사용자 개인정보 수정 이력을 저장하는 Audit Log 시스템이 있다. 현재 시스템은 다음과 같이 동작한다:

### 배경
> - 여러 애플리케이션 서버가 로드밸런서를 통해 분산 요청을 처리한다.
> - 각 서버는 요청을 처리하면서 타임스탬프(yyyyMMddHHmmssSSS)를 문자열로 변환한 값을 사용하고, 이 값을 데이터베이스에 저장한다.
> - 그러나 데이터베이스에 Unique 제약이 없거나, 동일한 타임스탬프가 생성될 경우 중복 ID가 발생해 로그 정합성이 깨지는 문제가 생긴다.


### 문제 상황 예시
> 동일 사용자 요청이 두 서버에서 같은 밀리초(ms) 안에 처리되면 동일한 ID가 생성되어 충돌한다.
그 결과 일부 로그는 중복 저장되거나, Unique 제약이 있을 경우 삽입 실패(409/500) 로 이어진다.
시간 순 정렬 기준이 깨져 “최신 이력” 판단이 틀리는 문제도 발생한다.

### 요구사항
> 위 문제를 방지하기 위해, 분산 환경에서도 전역적으로 유일하고 정렬 가능한 ID를 생성하는 시스템을 설계하시오.

#### 기능 요구사항
- **전역 유일성(Global Uniqueness)**
  - 모든 서버에서 생성된 ID가 서로 중복되지 않아야 한다
- **정렬 가능성(Sortability)**
  - 시간 흐름에 따라 ID가 단조 증가해야 하며, 이력 정렬에 활용 가능해야 한다
- **재시도 및 충돌 처리 로직**
  - 동일 밀리초 내 충돌 시, sequence 증가 또는 재시도로 충돌 회피
- **운영 편의성**
  - 서버 증감이 유일 ID 시스템에 영향가지 않도록 설계할 것
- **대용량 트래픽 처리 성능**
  - 초당 20,000건 이상의 요청에서 충돌 없이 ID를 생성할 수 있어야 한다.

## 2. 풀이
> Snowflake(타임스탬프+데이터센터 ID+서버 ID+시퀀스) 를 적용한 ID 생성기를 사용한다. 
> 
> Snowflake는 각 서버마다 유일한 ID를 보장해주는 기법이다.
> <img src="img/snowflake_이미지.png">
> - 타임스탬프 : 41비트를 할당한다. ms 기준이고, 기준 시간을 1970년 1월 1일이 아닌 다른 시작 시작시간을 설정하여 더 길게 사용할 수 있다.
> - 데이터센터 ID : 5비트를 할당한다. 2^5 = 32 개의 데이터 센터를 지원한다.
> - 서버 ID : 5비트를 할당한다. 즉 데이터 센터당 32 개의 서버를 지원한다.
> - 시퀀스(일련번호) : 12비트를 할당한다.(최대 4096) 각 서버에서 ID를 생성할때마다 이 일련번호를 1씩 증가시키고, 1ms 가 지날때마다 다시 0으로 초기화 시킨다.

### 기능 요구사항 충족
1. **전역 유일성(Global Uniqueness)**
   - 타임스탬프 + 데이터센터ID + 서버ID + 시퀀스의 조합을 이용해 같은 millisecond 라도 유일한 ID를 생성할 수 있다.
     - **주의사항** : 데이터센터ID, 서버ID는 반드시 고유하게 할당되어야 함  

2. **정렬 가능성(Sortability)**
   - 타임스탬프를 이용하기 때문에 시간순으로 정렬이 가능하고 만약 같은 타임스탬프를 가졌더라도 시퀀스를 이용하여 해결 가능
     - 각기 다른 데이터센터에서 동일한 타임스탬프 + 같은 시퀀스 값이라면 정확하게 정렬은 불가능하나, 실무에서 이런 요구사항이 과연 있을까..?

3. **재시도 및 충돌 처리 로직**
   - 기본적으로 동일 밀리세컨드여도 시퀀스를 이용하여 처리 가능
   - 시퀀스가 최고점(4096)에 도달하면 현재 ms가 끝날때까지 블로킹처리를 통해 다음 ms에서 시퀀스 0으로 초기화 후 생성

4. **운영 편의성**
   - 서버마다 고유한 ID를 부여받기 때문에 서버가 증감시에도 유연하게 대응 가능
   - 서버 제거/추가 시 Redis 같은 중앙 저장소를 이용하여 서버ID 관리

5. **대용량 트래픽 처리 성능**
   - 1000ms = 1s , 1ms 당 4096 개의 ID 생성 가능 -> 이론상 1000ms * 4096 = 4,096,000개의 ID를 생성 가능
   - 물론 실제 환경에서는 어플리케이션 성능과 네트워크 등 복합적인 이유로 저 정도의 성능이 나오지 않을것으로 예상

## 3.정리
> Snowflake 기법을 이용하면 주어진 요구사항을 모두 충족 가능하지만 실제 실무에서 적용시에는 고려해야할 점이 많다.
> 1. 동적으로 늘어나고 줄어드는 서버에 맞춰 ID 관리 필요 (서버 추가시 id 획득 실패시 어떻게 처리하는가?)
> 2. 네트워크 이슈로 인하여 DB insert 실패시 같은 상황에서는 같은 ID를 사용하여 재시도하지 않는 등 여러 충돌 케이스 고민 필요(실제 DB insert는 됐으나, 네트워크 이슈로 응답을 받지 못한다던가 하는 케이스)
> 3. 각 서버마다 다른 시계를 사용한다면..?
# 📌 1주차 문제 풀이

## 1. 문제 상황

### 데이터베이스 구조
- **Master (쓰기 전용)**: 모든 `INSERT / UPDATE / DELETE` 처리
- **Follower-1 (읽기 전용)**: Master의 **Binlog**를 기반으로 **비동기 복제(asynchronous replication)** 수행
- **구성**: `1 Master + 1 Follower`

### 서비스 아키텍처
- **상품관리 서버 (Product Management Service)**  
  → 상품 데이터 수정 요청 시 **Master DB**에 쓰기 요청 전송
- **상품조회 서버 (Product Query Service)**  
  → 상품 데이터 조회 요청 시 **Follower DB**에 읽기 요청 전송

---

## 2. 시나리오

1. 판매자가 상품 **"사과"의 재고**를 `400 → 0`으로 수정
2. 상품관리 서버 → Master DB: `UPDATE 실행`
3. Master DB → Follower DB: Binlog 전송 (비동기 복제)
4. 사용자 → 상품조회 서버: **사과 재고 조회 요청**
5. Follower DB에서 조회 → 아직 반영되지 않아 **400 노출**

⚠️ **문제점**
- 비동기 복제 지연(Replication Lag)으로 인해  
  Master에는 `0`으로 반영되었지만, Follower는 `400`으로 남아  
  사용자가 **잘못된 데이터**를 확인하는 현상 발생

---

## 3. 해결 방법

✅ **캐시 레이어(Cache Layer) 추가**
- Master DB 업데이트 시 변경된 데이터를 **Cache 서버에 즉시 반영**
- 상품조회 서버는 우선 **Cache**를 조회하고, 없거나 만료 시 Follower DB에서 조회

---

## 4. 다이어그램 흐름

1. 판매자 → 상품관리 서버: `재고 변경 요청 (사과: 400 → 0)`
2. 상품관리 서버 → Master DB: `UPDATE`
3. Master DB → Cache 서버: `변경된 상품 정보 캐싱(TTL 설정은 얼마나?)`
4. Master DB → Follower DB: `Binlog 전송 (비동기)`
5. 사용자 → 상품조회 서버: `사과 재고 조회 요청`
6. 상품조회 서버 동작:
    - **Case 1:** Cache에서 조회 → 최신 데이터(`0`) 반환
    - **Case 2:** Follower DB에서 조회 → 최신 데이터(`0`, Replication 반영 후)

---

## 5. 문제점
1. TTL이 만료될때까지 비동기 복제가 완료되지 않았다면?
2. 인기 상품 캐시가 동시에 TTL이 만료된다면 -> 순간 DB 트래픽 폭주

---

## 6. 번외 해결법: 주문 서버 분리

문제의 본질은 **재고가 잘못 표시되어 잘못된 주문이 발생할 수 있음**이라고 생각  
따라서 **조회와 주문 경로를 분리**하는 방법도 고려할 수 있다.

- **조회 서버(Product Query Service)**  
  → 캐시 또는 Follower DB 기반 조회 (eventual consistency 허용 가능)  
  → 사용자 경험 중심: 빠른 응답 제공

- **주문 서버(Order Service)**  
  → 반드시 **Master DB**를 직접 조회  
  → 항상 최신 재고 기반으로 주문 생성 → 잘못된 주문 방지

### 장점
- 잘못된 재고를 기반으로 주문이 발생하는 문제를 근본적으로 차단
- 조회와 주문의 특성을 분리하여 각기 다른 일관성 수준(consistency level) 적용 가능

### 단점
- 인기 상품의 주문이 몰리면 Master DB 부하 증가
- 사용자가 조회할 때와 실제 주문 시점의 재고가 다를 수 있음  
  (예: 조회 시 400, 주문 시 0 → 주문 불가)

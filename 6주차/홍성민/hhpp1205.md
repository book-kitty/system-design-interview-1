# 채팅 시스템 메시징 구조 및 데이터 흐름
![스크린샷 2025-10-29 234135.png](img%2F%BD%BA%C5%A9%B8%B0%BC%A6%202025-10-29%20234135.png)
## 1. 데이터 흐름

1. 사용자 **A**가 **채팅 서버**로 메시지를 전송한다.
2. 채팅 서버는 **ID 생성기**를 통해 고유한 메시지 ID를 생성한다.
3. 채팅 서버는 해당 메시지를 **메시지 동기화 큐(Message Sync Queue)** 로 전송한다.
4. 메시지는 **키-값 저장소(Key-Value Store)** 에 저장된다.
5. 이후 수신자 상태에 따라 다음과 같이 처리된다.
    - (a) **사용자 B가 접속 중인 경우:**  
      메시지가 B가 연결된 **채팅 서버**로 전달된다.
    - (b) **사용자 B가 오프라인인 경우:**  
      **푸시 알림 서버**로 전달되어 알림이 전송된다.
6. 채팅 서버는 **WebSocket 연결**을 통해 사용자 B에게 실시간으로 메시지를 전달한다.

---

## 2. 메시징 인프라 (Kafka 중심)

| 항목 | 설정 / 설명                                                                                        |
| --- |------------------------------------------------------------------------------------------------|
| **1. 복제(Replication Factor)** | `RF = 3` 설정 — 메시지를 3개의 Kafka 노드(AZ 분산)에 복제 저장                                                  |
| **2. ACK 정책** | `acks = all` — 리더 및 ISR(모든 복제본)의 쓰기 완료 후 ACK 반환                                                |
| **3. 파티션 구성** | 채팅방당 1개의 파티션을 부여하여 **메시지 순서/일관성 보장**                                                           |
| **4. 순서 보장 정책** | 동일 채팅방 내 메시지는 단일 파티션에서 처리되어 모든 참여자에게 동일 순서로 표시                                                 |
| **5. 병목 방지 전략** | - 짧은 시간에 과도한 메시지 발생 시 **전송 제한** 적용<br>- 오픈채팅은 **1500명 제한** |

---

## 3. Redis 기반 메시지 커서 관리

- Redis의 **ZSET(정렬집합)** 을 사용하여 `ZADD GT` 옵션으로  
  “현재 값보다 큰 경우에만 갱신”하는 방식으로 **마지막 읽은 메시지 ID** 를 저장한다.
- 이 구조를 통해 **원자적(atomic)** 으로 “가장 큰 메시지 ID만 기록”할 수 있다.
- 앱/브라우저 재시작, 네트워크 전환 시에도 Redis에서 해당 사용자-채팅방 기준  
  마지막 읽은 메시지 ID를 조회하여 빠르게 복원한다.

---

## 4. 단말(Local) 메시지 동기화 정책

- 단말은 대화 내역을 **로컬 캐시(Local Storage)** 에 보관한다.
- 앱 재시작 또는 재접속 시 다음 절차로 최신화한다:
    1. Redis에서 **마지막 읽은 메시지 ID** 조회
    2. 단말에 저장된 **마지막 메시지 ID** 와 비교
    3. 값이 다를 경우 서버에서 해당 구간의 대화 내역을 조회 후 단말에 반영
- 이를 통해 메시지 조회 API 호출 횟수를 최소화하면서  
  복구 시간은 **1초 이내**로 유지한다.

---
# 서비스 구조 및 문제 해결

## 서비스 구조
- **Client**: 모바일/웹 사용자 (좌석 조회 및 예매 요청)
- **API Gateway**: 모든 외부 요청이 통과하는 입구, 처리율 제한 장치를 두어야 함
- **Application Server**: 좌석 조회, 예매, 결제 등 비즈니스 로직 처리
- **Redis Cluster**: 분산 환경에서 공유 가능한 카운터 저장소
- **Database**: 좌석 및 예매 내역 최종 저장소

---

## 상황
- 특정 API(예매 요청)는 사용자별로 **1분에 최대 60회 요청만 허용**해야 함.
- 인기 콘서트 예매 시, 한 사용자가 **초당 수백 건의 요청**을 보내고 있음.
- 단일 서버 환경에서는 **In-Memory 기반 Rate Limiter**로 정상 동작했음.
- 하지만 서버가 **3대로 확장**되자, 동일 사용자가 동시에 3대 서버에 요청을 보내며 제한이 무력화됨.

---

## 문제점
1. **서버별 카운터 분리**
    - In-Memory Counter는 서버별로 따로 유지됨
    - 서버가 여러 대일 경우 제한이 깨짐
    - 예: 3대 서버에서 각각 60회 허용 → 최대 180회까지 우회 가능

2. **Race Condition**
    - 동시에 요청이 몰리면 Redis 카운터 증가/검증 시점 차이로 제한이 정확히 적용되지 않을 수 있음

3. **Foxed Window 경계**
   - 윈도 경계 부근에서 트레픽이 폭주 할 수 있음
---

## 해결 방법
1. **In-Memory Counter → Redis 기반 카운터로 전환**
    - 모든 Application Server가 단일 Redis Cluster를 바라보도록 구성
    - 사용자별 요청 수를 Redis에서 전역적으로 관리하여 서버 수와 무관하게 일관된 제한 적용

2. **Redis Cluster 도입**
    - 단일 Redis 인스턴스의 SPOF(Single Point of Failure) 문제를 제거
    - 고가용성과 확장성을 보장

3. **Race Condition 해결**
    - Redis의 **Lua Script**를 활용하여 요청 검증과 카운트 증가를 **원자적(Atomic)**으로 처리
    - 동시에 요청이 몰려도 정확한 제한 보장
    - 예: `GET → 비교 → INCR`를 Lua Script로 묶어 실행

4. **고정 윈도 카운터 알고리즘 -> 이동 윈도 로깅 알고리즘 전환**
   - 이동 윈도 로깅 알고리즘은 요청이 들어왔을 때 현지 시각 ~ 과거 윈도 시간까지의 요청을 로깅하여 제한 범위가 넘어갔을 경우 요청 거부하기 
때문에 고정 윈도 카운터 알고리즘을 사용했을 때 발생하는 윈도 경계 부근에서 트레픽이 폭주하는 현상을 예방할 수 있다.
---
